/**
 * Generated by orval v7.9.0 🍺
 * Do not edit manually.
 * ATSPM Configuration Api
 * ATSPM Configuration with OData, OpenAPI, Swashbuckle, and API versioning.
 * OpenAPI spec version: 1.0
 */
import {
  useMutation,
  useQuery
} from 'react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from 'react-query';

import type {
  Device,
  DeviceGroup,
  GetDeviceActiveDevicesByLocationFromLocationIdParams,
  GetDeviceActiveDevicesCountParams,
  GetDeviceCountParams,
  GetDeviceFromKeyParams,
  GetDeviceParams,
  PatchDeviceFromKeyParams,
  PostDeviceParams,
  PutDeviceFromKeyParams
} from '../aTSPMConfigurationApi.schemas';

import { configRequest } from '../../../lib/axios';




/**
 * @summary Gets all Utah.Udot.Atspm.Data.Models.Device from locationId where Utah.Udot.Atspm.Data.Models.Device.DeviceStatus equals Utah.Udot.Atspm.Data.Enums.DeviceStatus.Active
 */
export const getDeviceActiveDevicesByLocationFromLocationId = (
    locationId: number,
    params?: GetDeviceActiveDevicesByLocationFromLocationIdParams,
 signal?: AbortSignal
) => {
      
      
      return configRequest<Device[]>(
      {url: `/Device/GetActiveDevicesByLocation(locationId=${locationId})`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetDeviceActiveDevicesByLocationFromLocationIdQueryKey = (locationId: number,
    params?: GetDeviceActiveDevicesByLocationFromLocationIdParams,) => {
    return [`/Device/GetActiveDevicesByLocation(locationId=${locationId})`, ...(params ? [params]: [])] as const;
    }

    
export const getGetDeviceActiveDevicesByLocationFromLocationIdQueryOptions = <TData = Awaited<ReturnType<typeof getDeviceActiveDevicesByLocationFromLocationId>>, TError = void>(locationId: number,
    params?: GetDeviceActiveDevicesByLocationFromLocationIdParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getDeviceActiveDevicesByLocationFromLocationId>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDeviceActiveDevicesByLocationFromLocationIdQueryKey(locationId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDeviceActiveDevicesByLocationFromLocationId>>> = ({ signal }) => getDeviceActiveDevicesByLocationFromLocationId(locationId,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(locationId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDeviceActiveDevicesByLocationFromLocationId>>, TError, TData> & { queryKey: QueryKey }
}

export type GetDeviceActiveDevicesByLocationFromLocationIdQueryResult = NonNullable<Awaited<ReturnType<typeof getDeviceActiveDevicesByLocationFromLocationId>>>
export type GetDeviceActiveDevicesByLocationFromLocationIdQueryError = void


/**
 * @summary Gets all Utah.Udot.Atspm.Data.Models.Device from locationId where Utah.Udot.Atspm.Data.Models.Device.DeviceStatus equals Utah.Udot.Atspm.Data.Enums.DeviceStatus.Active
 */

export function useGetDeviceActiveDevicesByLocationFromLocationId<TData = Awaited<ReturnType<typeof getDeviceActiveDevicesByLocationFromLocationId>>, TError = void>(
 locationId: number,
    params?: GetDeviceActiveDevicesByLocationFromLocationIdParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getDeviceActiveDevicesByLocationFromLocationId>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetDeviceActiveDevicesByLocationFromLocationIdQueryOptions(locationId,params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Gets a count of device type for all active devices Utah.Udot.Atspm.Data.Models.Device where Utah.Udot.Atspm.Data.Models.Device.DeviceStatus equals Utah.Udot.Atspm.Data.Enums.DeviceStatus.Active
 */
export const getDeviceActiveDevicesCount = (
    params?: GetDeviceActiveDevicesCountParams,
 signal?: AbortSignal
) => {
      
      
      return configRequest<DeviceGroup[]>(
      {url: `/Device/GetActiveDevicesCount`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetDeviceActiveDevicesCountQueryKey = (params?: GetDeviceActiveDevicesCountParams,) => {
    return [`/Device/GetActiveDevicesCount`, ...(params ? [params]: [])] as const;
    }

    
export const getGetDeviceActiveDevicesCountQueryOptions = <TData = Awaited<ReturnType<typeof getDeviceActiveDevicesCount>>, TError = void>(params?: GetDeviceActiveDevicesCountParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getDeviceActiveDevicesCount>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDeviceActiveDevicesCountQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDeviceActiveDevicesCount>>> = ({ signal }) => getDeviceActiveDevicesCount(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDeviceActiveDevicesCount>>, TError, TData> & { queryKey: QueryKey }
}

export type GetDeviceActiveDevicesCountQueryResult = NonNullable<Awaited<ReturnType<typeof getDeviceActiveDevicesCount>>>
export type GetDeviceActiveDevicesCountQueryError = void


/**
 * @summary Gets a count of device type for all active devices Utah.Udot.Atspm.Data.Models.Device where Utah.Udot.Atspm.Data.Models.Device.DeviceStatus equals Utah.Udot.Atspm.Data.Enums.DeviceStatus.Active
 */

export function useGetDeviceActiveDevicesCount<TData = Awaited<ReturnType<typeof getDeviceActiveDevicesCount>>, TError = void>(
 params?: GetDeviceActiveDevicesCountParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getDeviceActiveDevicesCount>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetDeviceActiveDevicesCountQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getDevice = (
    params?: GetDeviceParams,
 signal?: AbortSignal
) => {
      
      
      return configRequest<Device[]>(
      {url: `/Device`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetDeviceQueryKey = (params?: GetDeviceParams,) => {
    return [`/Device`, ...(params ? [params]: [])] as const;
    }

    
export const getGetDeviceQueryOptions = <TData = Awaited<ReturnType<typeof getDevice>>, TError = void>(params?: GetDeviceParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getDevice>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDeviceQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDevice>>> = ({ signal }) => getDevice(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDevice>>, TError, TData> & { queryKey: QueryKey }
}

export type GetDeviceQueryResult = NonNullable<Awaited<ReturnType<typeof getDevice>>>
export type GetDeviceQueryError = void



export function useGetDevice<TData = Awaited<ReturnType<typeof getDevice>>, TError = void>(
 params?: GetDeviceParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getDevice>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetDeviceQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const postDevice = (
    device: Device,
    params?: PostDeviceParams,
 signal?: AbortSignal
) => {
      
      
      return configRequest<void>(
      {url: `/Device`, method: 'POST',
      headers: {'Content-Type': 'application/json;odata.metadata=minimal;odata.streaming=true', },
      data: device,
        params, signal
    },
      );
    }
  


export const getPostDeviceMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postDevice>>, TError,{data: Device;params?: PostDeviceParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postDevice>>, TError,{data: Device;params?: PostDeviceParams}, TContext> => {

const mutationKey = ['postDevice'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postDevice>>, {data: Device;params?: PostDeviceParams}> = (props) => {
          const {data,params} = props ?? {};

          return  postDevice(data,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostDeviceMutationResult = NonNullable<Awaited<ReturnType<typeof postDevice>>>
    export type PostDeviceMutationBody = Device
    export type PostDeviceMutationError = void

    export const usePostDevice = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postDevice>>, TError,{data: Device;params?: PostDeviceParams}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof postDevice>>,
        TError,
        {data: Device;params?: PostDeviceParams},
        TContext
      > => {

      const mutationOptions = getPostDeviceMutationOptions(options);

      return useMutation(mutationOptions );
    }
    export const getDeviceCount = (
    params?: GetDeviceCountParams,
 signal?: AbortSignal
) => {
      
      
      return configRequest<Device[]>(
      {url: `/Device/$count`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetDeviceCountQueryKey = (params?: GetDeviceCountParams,) => {
    return [`/Device/$count`, ...(params ? [params]: [])] as const;
    }

    
export const getGetDeviceCountQueryOptions = <TData = Awaited<ReturnType<typeof getDeviceCount>>, TError = void>(params?: GetDeviceCountParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getDeviceCount>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDeviceCountQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDeviceCount>>> = ({ signal }) => getDeviceCount(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDeviceCount>>, TError, TData> & { queryKey: QueryKey }
}

export type GetDeviceCountQueryResult = NonNullable<Awaited<ReturnType<typeof getDeviceCount>>>
export type GetDeviceCountQueryError = void



export function useGetDeviceCount<TData = Awaited<ReturnType<typeof getDeviceCount>>, TError = void>(
 params?: GetDeviceCountParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getDeviceCount>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetDeviceCountQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getDeviceFromKey = (
    key: number,
    params?: GetDeviceFromKeyParams,
 signal?: AbortSignal
) => {
      
      
      return configRequest<Device>(
      {url: `/Device/${key}`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetDeviceFromKeyQueryKey = (key: number,
    params?: GetDeviceFromKeyParams,) => {
    return [`/Device/${key}`, ...(params ? [params]: [])] as const;
    }

    
export const getGetDeviceFromKeyQueryOptions = <TData = Awaited<ReturnType<typeof getDeviceFromKey>>, TError = void>(key: number,
    params?: GetDeviceFromKeyParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getDeviceFromKey>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDeviceFromKeyQueryKey(key,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDeviceFromKey>>> = ({ signal }) => getDeviceFromKey(key,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(key), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDeviceFromKey>>, TError, TData> & { queryKey: QueryKey }
}

export type GetDeviceFromKeyQueryResult = NonNullable<Awaited<ReturnType<typeof getDeviceFromKey>>>
export type GetDeviceFromKeyQueryError = void



export function useGetDeviceFromKey<TData = Awaited<ReturnType<typeof getDeviceFromKey>>, TError = void>(
 key: number,
    params?: GetDeviceFromKeyParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getDeviceFromKey>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetDeviceFromKeyQueryOptions(key,params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const putDeviceFromKey = (
    key: number,
    device: Device,
    params?: PutDeviceFromKeyParams,
 ) => {
      
      
      return configRequest<void>(
      {url: `/Device/${key}`, method: 'PUT',
      headers: {'Content-Type': 'application/json;odata.metadata=minimal;odata.streaming=true', },
      data: device,
        params
    },
      );
    }
  


export const getPutDeviceFromKeyMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putDeviceFromKey>>, TError,{key: number;data: Device;params?: PutDeviceFromKeyParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof putDeviceFromKey>>, TError,{key: number;data: Device;params?: PutDeviceFromKeyParams}, TContext> => {

const mutationKey = ['putDeviceFromKey'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putDeviceFromKey>>, {key: number;data: Device;params?: PutDeviceFromKeyParams}> = (props) => {
          const {key,data,params} = props ?? {};

          return  putDeviceFromKey(key,data,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutDeviceFromKeyMutationResult = NonNullable<Awaited<ReturnType<typeof putDeviceFromKey>>>
    export type PutDeviceFromKeyMutationBody = Device
    export type PutDeviceFromKeyMutationError = void

    export const usePutDeviceFromKey = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putDeviceFromKey>>, TError,{key: number;data: Device;params?: PutDeviceFromKeyParams}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof putDeviceFromKey>>,
        TError,
        {key: number;data: Device;params?: PutDeviceFromKeyParams},
        TContext
      > => {

      const mutationOptions = getPutDeviceFromKeyMutationOptions(options);

      return useMutation(mutationOptions );
    }
    export const patchDeviceFromKey = (
    key: number,
    device: Device,
    params?: PatchDeviceFromKeyParams,
 ) => {
      
      
      return configRequest<void>(
      {url: `/Device/${key}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json;odata.metadata=minimal;odata.streaming=true', },
      data: device,
        params
    },
      );
    }
  


export const getPatchDeviceFromKeyMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchDeviceFromKey>>, TError,{key: number;data: Device;params?: PatchDeviceFromKeyParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof patchDeviceFromKey>>, TError,{key: number;data: Device;params?: PatchDeviceFromKeyParams}, TContext> => {

const mutationKey = ['patchDeviceFromKey'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchDeviceFromKey>>, {key: number;data: Device;params?: PatchDeviceFromKeyParams}> = (props) => {
          const {key,data,params} = props ?? {};

          return  patchDeviceFromKey(key,data,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchDeviceFromKeyMutationResult = NonNullable<Awaited<ReturnType<typeof patchDeviceFromKey>>>
    export type PatchDeviceFromKeyMutationBody = Device
    export type PatchDeviceFromKeyMutationError = void

    export const usePatchDeviceFromKey = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchDeviceFromKey>>, TError,{key: number;data: Device;params?: PatchDeviceFromKeyParams}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof patchDeviceFromKey>>,
        TError,
        {key: number;data: Device;params?: PatchDeviceFromKeyParams},
        TContext
      > => {

      const mutationOptions = getPatchDeviceFromKeyMutationOptions(options);

      return useMutation(mutationOptions );
    }
    export const deleteDeviceFromKey = (
    key: number,
 ) => {
      
      
      return configRequest<void>(
      {url: `/Device/${key}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteDeviceFromKeyMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDeviceFromKey>>, TError,{key: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteDeviceFromKey>>, TError,{key: number}, TContext> => {

const mutationKey = ['deleteDeviceFromKey'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteDeviceFromKey>>, {key: number}> = (props) => {
          const {key} = props ?? {};

          return  deleteDeviceFromKey(key,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteDeviceFromKeyMutationResult = NonNullable<Awaited<ReturnType<typeof deleteDeviceFromKey>>>
    
    export type DeleteDeviceFromKeyMutationError = void

    export const useDeleteDeviceFromKey = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDeviceFromKey>>, TError,{key: number}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteDeviceFromKey>>,
        TError,
        {key: number},
        TContext
      > => {

      const mutationOptions = getDeleteDeviceFromKeyMutationOptions(options);

      return useMutation(mutationOptions );
    }
    