/**
 * Generated by orval v7.9.0 ðŸº
 * Do not edit manually.
 * ATSPM Data Api
 * ATSPM Data with OpenAPI, Swashbuckle, and API versioning.
 * OpenAPI spec version: 1.0
 */
import {
  useQuery
} from 'react-query';
import type {
  QueryFunction,
  QueryKey,
  UseQueryOptions,
  UseQueryResult
} from 'react-query';

import type {
  CompressedDataBase,
  DataTypeMeta,
  GetAggregationDataFromLocationIdentifierAndDataTypeParams,
  GetAggregationDataFromLocationIdentifierParams,
  GetAggregationDaysWithDataFromLocationIdentifierAndDataTypeParams,
  GetAggregationStreamDataFromLocationIdentifierAndDataTypeParams,
  GetAggregationStreamDataFromLocationIdentifierParams,
  ProblemDetails
} from '../data-api.schemas';

import { dataRequest } from '../../../lib/axios';




/**
 * @summary Retrieves the available derived data types defined in the system.
 */
export const getAggregationDataTypes = (
    
 signal?: AbortSignal
) => {
      
      
      return dataRequest<DataTypeMeta[]>(
      {url: `/api/v1/Aggregation/GetDataTypes`, method: 'GET', signal
    },
      );
    }
  

export const getGetAggregationDataTypesQueryKey = () => {
    return [`/api/v1/Aggregation/GetDataTypes`] as const;
    }

    
export const getGetAggregationDataTypesQueryOptions = <TData = Awaited<ReturnType<typeof getAggregationDataTypes>>, TError = ProblemDetails>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAggregationDataTypes>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAggregationDataTypesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAggregationDataTypes>>> = ({ signal }) => getAggregationDataTypes(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAggregationDataTypes>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAggregationDataTypesQueryResult = NonNullable<Awaited<ReturnType<typeof getAggregationDataTypes>>>
export type GetAggregationDataTypesQueryError = ProblemDetails


/**
 * @summary Retrieves the available derived data types defined in the system.
 */

export function useGetAggregationDataTypes<TData = Awaited<ReturnType<typeof getAggregationDataTypes>>, TError = ProblemDetails>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAggregationDataTypes>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAggregationDataTypesQueryOptions(options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * ### Response Format
- Content type: `application/x-ndjson`
- Each line is a JSON object representing a <typeparamref name="T1" /> record.
- Clients should parse line-by-line rather than expecting a JSON array.
            
### Example Request
- GET /StreamData/1014?start=2024-01-01&end=2024-12-31
            
### Example Response (NDJSON)
```
{"locationId":"1014","start":"2024-01-01T00:00:00Z","end":"2024-01-01T23:59:59Z"}
{"locationId":"1014","start":"2024-01-02T00:00:00Z","end":"2024-01-02T23:59:59Z"}
```
            
### Streaming and Cancellation
- Results are streamed using `IAsyncEnumerable`.
- Clients can cancel by aborting the HTTP request (e.g., disposing `HttpClient` in .NET or calling `AbortController.abort()` in JavaScript).
- Cancellation immediately stops enumeration and closes the response.
 * @summary Streams archived data records for a specific location within a given date range.
 */
export const getAggregationStreamDataFromLocationIdentifier = (
    locationIdentifier: string,
    params?: GetAggregationStreamDataFromLocationIdentifierParams,
 signal?: AbortSignal
) => {
      
      
      return dataRequest<CompressedDataBase>(
      {url: `/api/v1/Aggregation/StreamData/${locationIdentifier}`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetAggregationStreamDataFromLocationIdentifierQueryKey = (locationIdentifier: string,
    params?: GetAggregationStreamDataFromLocationIdentifierParams,) => {
    return [`/api/v1/Aggregation/StreamData/${locationIdentifier}`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAggregationStreamDataFromLocationIdentifierQueryOptions = <TData = Awaited<ReturnType<typeof getAggregationStreamDataFromLocationIdentifier>>, TError = ProblemDetails>(locationIdentifier: string,
    params?: GetAggregationStreamDataFromLocationIdentifierParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAggregationStreamDataFromLocationIdentifier>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAggregationStreamDataFromLocationIdentifierQueryKey(locationIdentifier,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAggregationStreamDataFromLocationIdentifier>>> = ({ signal }) => getAggregationStreamDataFromLocationIdentifier(locationIdentifier,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(locationIdentifier), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAggregationStreamDataFromLocationIdentifier>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAggregationStreamDataFromLocationIdentifierQueryResult = NonNullable<Awaited<ReturnType<typeof getAggregationStreamDataFromLocationIdentifier>>>
export type GetAggregationStreamDataFromLocationIdentifierQueryError = ProblemDetails


/**
 * @summary Streams archived data records for a specific location within a given date range.
 */

export function useGetAggregationStreamDataFromLocationIdentifier<TData = Awaited<ReturnType<typeof getAggregationStreamDataFromLocationIdentifier>>, TError = ProblemDetails>(
 locationIdentifier: string,
    params?: GetAggregationStreamDataFromLocationIdentifierParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAggregationStreamDataFromLocationIdentifier>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAggregationStreamDataFromLocationIdentifierQueryOptions(locationIdentifier,params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * ### Response Format
- Content type: `application/json`
- Response is a JSON array of Utah.Udot.Atspm.Data.Models.CompressedDataBase objects.
            
### Example Request
- GET /GetData/1014?start=2024-01-01&end=2024-12-31
            
### Example Response (JSON Array)
```json
[
  {"locationId":"1014","start":"2024-01-01T00:00:00Z","end":"2024-01-01T23:59:59Z"},
  {"locationId":"1014","start":"2024-01-02T00:00:00Z","end":"2024-01-02T23:59:59Z"}
]
```
 * @summary Retrieves archived data records for a specific location within a given date range.
 */
export const getAggregationDataFromLocationIdentifier = (
    locationIdentifier: string,
    params?: GetAggregationDataFromLocationIdentifierParams,
 signal?: AbortSignal
) => {
      
      
      return dataRequest<CompressedDataBase[]>(
      {url: `/api/v1/Aggregation/GetData/${locationIdentifier}`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetAggregationDataFromLocationIdentifierQueryKey = (locationIdentifier: string,
    params?: GetAggregationDataFromLocationIdentifierParams,) => {
    return [`/api/v1/Aggregation/GetData/${locationIdentifier}`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAggregationDataFromLocationIdentifierQueryOptions = <TData = Awaited<ReturnType<typeof getAggregationDataFromLocationIdentifier>>, TError = ProblemDetails>(locationIdentifier: string,
    params?: GetAggregationDataFromLocationIdentifierParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAggregationDataFromLocationIdentifier>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAggregationDataFromLocationIdentifierQueryKey(locationIdentifier,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAggregationDataFromLocationIdentifier>>> = ({ signal }) => getAggregationDataFromLocationIdentifier(locationIdentifier,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(locationIdentifier), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAggregationDataFromLocationIdentifier>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAggregationDataFromLocationIdentifierQueryResult = NonNullable<Awaited<ReturnType<typeof getAggregationDataFromLocationIdentifier>>>
export type GetAggregationDataFromLocationIdentifierQueryError = ProblemDetails


/**
 * @summary Retrieves archived data records for a specific location within a given date range.
 */

export function useGetAggregationDataFromLocationIdentifier<TData = Awaited<ReturnType<typeof getAggregationDataFromLocationIdentifier>>, TError = ProblemDetails>(
 locationIdentifier: string,
    params?: GetAggregationDataFromLocationIdentifierParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAggregationDataFromLocationIdentifier>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAggregationDataFromLocationIdentifierQueryOptions(locationIdentifier,params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * ### Response Format
- Content type: `application/x-ndjson`
- Each line is a JSON object representing a CompressedDataBase record.
- Clients should parse line-by-line rather than expecting a JSON array.
            
### Example Request
- GET /StreamData/1014?start=2024-01-01&end=2024-12-31&dataType=[dataType]
            
### Example Response (NDJSON)
```
{"locationId":"1014","start":"2024-01-01T00:00:00Z","end":"2024-01-01T23:59:59Z"}
{"locationId":"1014","start":"2024-01-02T00:00:00Z","end":"2024-01-02T23:59:59Z"}
```
 * @summary Streams archived data records for a specific location and data type within a given date range.
 */
export const getAggregationStreamDataFromLocationIdentifierAndDataType = (
    locationIdentifier: string,
    dataType: 'AggregationApproachBase' | 'ApproachPcdAggregation' | 'ApproachSpeedAggregation' | 'ApproachSplitFailAggregation' | 'ApproachYellowRedActivationAggregation' | 'DetectorEventCountAggregation' | 'PhaseCycleAggregation' | 'PhaseLeftTurnGapAggregation' | 'PhasePedAggregation' | 'PhaseSplitMonitorAggregation' | 'PhaseTerminationAggregation' | 'PreemptionAggregation' | 'PriorityAggregation' | 'SignalEventCountAggregation' | 'SignalPlanAggregation',
    params?: GetAggregationStreamDataFromLocationIdentifierAndDataTypeParams,
 signal?: AbortSignal
) => {
      
      
      return dataRequest<CompressedDataBase>(
      {url: `/api/v1/Aggregation/StreamData/${locationIdentifier}/${dataType}`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetAggregationStreamDataFromLocationIdentifierAndDataTypeQueryKey = (locationIdentifier: string,
    dataType: 'AggregationApproachBase' | 'ApproachPcdAggregation' | 'ApproachSpeedAggregation' | 'ApproachSplitFailAggregation' | 'ApproachYellowRedActivationAggregation' | 'DetectorEventCountAggregation' | 'PhaseCycleAggregation' | 'PhaseLeftTurnGapAggregation' | 'PhasePedAggregation' | 'PhaseSplitMonitorAggregation' | 'PhaseTerminationAggregation' | 'PreemptionAggregation' | 'PriorityAggregation' | 'SignalEventCountAggregation' | 'SignalPlanAggregation',
    params?: GetAggregationStreamDataFromLocationIdentifierAndDataTypeParams,) => {
    return [`/api/v1/Aggregation/StreamData/${locationIdentifier}/${dataType}`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAggregationStreamDataFromLocationIdentifierAndDataTypeQueryOptions = <TData = Awaited<ReturnType<typeof getAggregationStreamDataFromLocationIdentifierAndDataType>>, TError = ProblemDetails>(locationIdentifier: string,
    dataType: 'AggregationApproachBase' | 'ApproachPcdAggregation' | 'ApproachSpeedAggregation' | 'ApproachSplitFailAggregation' | 'ApproachYellowRedActivationAggregation' | 'DetectorEventCountAggregation' | 'PhaseCycleAggregation' | 'PhaseLeftTurnGapAggregation' | 'PhasePedAggregation' | 'PhaseSplitMonitorAggregation' | 'PhaseTerminationAggregation' | 'PreemptionAggregation' | 'PriorityAggregation' | 'SignalEventCountAggregation' | 'SignalPlanAggregation',
    params?: GetAggregationStreamDataFromLocationIdentifierAndDataTypeParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAggregationStreamDataFromLocationIdentifierAndDataType>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAggregationStreamDataFromLocationIdentifierAndDataTypeQueryKey(locationIdentifier,dataType,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAggregationStreamDataFromLocationIdentifierAndDataType>>> = ({ signal }) => getAggregationStreamDataFromLocationIdentifierAndDataType(locationIdentifier,dataType,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(locationIdentifier && dataType), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAggregationStreamDataFromLocationIdentifierAndDataType>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAggregationStreamDataFromLocationIdentifierAndDataTypeQueryResult = NonNullable<Awaited<ReturnType<typeof getAggregationStreamDataFromLocationIdentifierAndDataType>>>
export type GetAggregationStreamDataFromLocationIdentifierAndDataTypeQueryError = ProblemDetails


/**
 * @summary Streams archived data records for a specific location and data type within a given date range.
 */

export function useGetAggregationStreamDataFromLocationIdentifierAndDataType<TData = Awaited<ReturnType<typeof getAggregationStreamDataFromLocationIdentifierAndDataType>>, TError = ProblemDetails>(
 locationIdentifier: string,
    dataType: 'AggregationApproachBase' | 'ApproachPcdAggregation' | 'ApproachSpeedAggregation' | 'ApproachSplitFailAggregation' | 'ApproachYellowRedActivationAggregation' | 'DetectorEventCountAggregation' | 'PhaseCycleAggregation' | 'PhaseLeftTurnGapAggregation' | 'PhasePedAggregation' | 'PhaseSplitMonitorAggregation' | 'PhaseTerminationAggregation' | 'PreemptionAggregation' | 'PriorityAggregation' | 'SignalEventCountAggregation' | 'SignalPlanAggregation',
    params?: GetAggregationStreamDataFromLocationIdentifierAndDataTypeParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAggregationStreamDataFromLocationIdentifierAndDataType>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAggregationStreamDataFromLocationIdentifierAndDataTypeQueryOptions(locationIdentifier,dataType,params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * ### Response Format
- Content type: `application/json`
- Response is a JSON array of Utah.Udot.Atspm.Data.Models.CompressedDataBase objects.
            
### Example Request
- GET /GetData/1014?start=2024-01-01&end=2024-12-31&dataType=[dataType]
            
### Example Response (JSON Array)
```json
[
  {"locationId":"1014","start":"2024-01-01T00:00:00Z","end":"2024-01-01T23:59:59Z"},
  {"locationId":"1014","start":"2024-01-02T00:00:00Z","end":"2024-01-02T23:59:59Z"}
]
```
 * @summary Retrieves archived data records for a specific location and data type within a given date range.
 */
export const getAggregationDataFromLocationIdentifierAndDataType = (
    locationIdentifier: string,
    dataType: 'AggregationApproachBase' | 'ApproachPcdAggregation' | 'ApproachSpeedAggregation' | 'ApproachSplitFailAggregation' | 'ApproachYellowRedActivationAggregation' | 'DetectorEventCountAggregation' | 'PhaseCycleAggregation' | 'PhaseLeftTurnGapAggregation' | 'PhasePedAggregation' | 'PhaseSplitMonitorAggregation' | 'PhaseTerminationAggregation' | 'PreemptionAggregation' | 'PriorityAggregation' | 'SignalEventCountAggregation' | 'SignalPlanAggregation',
    params?: GetAggregationDataFromLocationIdentifierAndDataTypeParams,
 signal?: AbortSignal
) => {
      
      
      return dataRequest<CompressedDataBase[]>(
      {url: `/api/v1/Aggregation/GetData/${locationIdentifier}/${dataType}`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetAggregationDataFromLocationIdentifierAndDataTypeQueryKey = (locationIdentifier: string,
    dataType: 'AggregationApproachBase' | 'ApproachPcdAggregation' | 'ApproachSpeedAggregation' | 'ApproachSplitFailAggregation' | 'ApproachYellowRedActivationAggregation' | 'DetectorEventCountAggregation' | 'PhaseCycleAggregation' | 'PhaseLeftTurnGapAggregation' | 'PhasePedAggregation' | 'PhaseSplitMonitorAggregation' | 'PhaseTerminationAggregation' | 'PreemptionAggregation' | 'PriorityAggregation' | 'SignalEventCountAggregation' | 'SignalPlanAggregation',
    params?: GetAggregationDataFromLocationIdentifierAndDataTypeParams,) => {
    return [`/api/v1/Aggregation/GetData/${locationIdentifier}/${dataType}`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAggregationDataFromLocationIdentifierAndDataTypeQueryOptions = <TData = Awaited<ReturnType<typeof getAggregationDataFromLocationIdentifierAndDataType>>, TError = ProblemDetails>(locationIdentifier: string,
    dataType: 'AggregationApproachBase' | 'ApproachPcdAggregation' | 'ApproachSpeedAggregation' | 'ApproachSplitFailAggregation' | 'ApproachYellowRedActivationAggregation' | 'DetectorEventCountAggregation' | 'PhaseCycleAggregation' | 'PhaseLeftTurnGapAggregation' | 'PhasePedAggregation' | 'PhaseSplitMonitorAggregation' | 'PhaseTerminationAggregation' | 'PreemptionAggregation' | 'PriorityAggregation' | 'SignalEventCountAggregation' | 'SignalPlanAggregation',
    params?: GetAggregationDataFromLocationIdentifierAndDataTypeParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAggregationDataFromLocationIdentifierAndDataType>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAggregationDataFromLocationIdentifierAndDataTypeQueryKey(locationIdentifier,dataType,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAggregationDataFromLocationIdentifierAndDataType>>> = ({ signal }) => getAggregationDataFromLocationIdentifierAndDataType(locationIdentifier,dataType,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(locationIdentifier && dataType), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAggregationDataFromLocationIdentifierAndDataType>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAggregationDataFromLocationIdentifierAndDataTypeQueryResult = NonNullable<Awaited<ReturnType<typeof getAggregationDataFromLocationIdentifierAndDataType>>>
export type GetAggregationDataFromLocationIdentifierAndDataTypeQueryError = ProblemDetails


/**
 * @summary Retrieves archived data records for a specific location and data type within a given date range.
 */

export function useGetAggregationDataFromLocationIdentifierAndDataType<TData = Awaited<ReturnType<typeof getAggregationDataFromLocationIdentifierAndDataType>>, TError = ProblemDetails>(
 locationIdentifier: string,
    dataType: 'AggregationApproachBase' | 'ApproachPcdAggregation' | 'ApproachSpeedAggregation' | 'ApproachSplitFailAggregation' | 'ApproachYellowRedActivationAggregation' | 'DetectorEventCountAggregation' | 'PhaseCycleAggregation' | 'PhaseLeftTurnGapAggregation' | 'PhasePedAggregation' | 'PhaseSplitMonitorAggregation' | 'PhaseTerminationAggregation' | 'PreemptionAggregation' | 'PriorityAggregation' | 'SignalEventCountAggregation' | 'SignalPlanAggregation',
    params?: GetAggregationDataFromLocationIdentifierAndDataTypeParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAggregationDataFromLocationIdentifierAndDataType>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAggregationDataFromLocationIdentifierAndDataTypeQueryOptions(locationIdentifier,dataType,params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * This endpoint allows anonymous access and returns a JSON array of System.DateOnly values.
Each value represents a day for which data exists. The request must specify a valid
location identifier, data type, and date range. If the inputs are invalid or the location/data type
cannot be resolved, an appropriate error response is returned.
 * @summary Retrieves the distinct days that contain data for a specific location and data type
within the given date range.
 */
export const getAggregationDaysWithDataFromLocationIdentifierAndDataType = (
    locationIdentifier: string,
    dataType: 'AggregationApproachBase' | 'ApproachPcdAggregation' | 'ApproachSpeedAggregation' | 'ApproachSplitFailAggregation' | 'ApproachYellowRedActivationAggregation' | 'DetectorEventCountAggregation' | 'PhaseCycleAggregation' | 'PhaseLeftTurnGapAggregation' | 'PhasePedAggregation' | 'PhaseSplitMonitorAggregation' | 'PhaseTerminationAggregation' | 'PreemptionAggregation' | 'PriorityAggregation' | 'SignalEventCountAggregation' | 'SignalPlanAggregation',
    params?: GetAggregationDaysWithDataFromLocationIdentifierAndDataTypeParams,
 signal?: AbortSignal
) => {
      
      
      return dataRequest<string[]>(
      {url: `/api/v1/Aggregation/GetDaysWithData/${locationIdentifier}/${dataType}`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetAggregationDaysWithDataFromLocationIdentifierAndDataTypeQueryKey = (locationIdentifier: string,
    dataType: 'AggregationApproachBase' | 'ApproachPcdAggregation' | 'ApproachSpeedAggregation' | 'ApproachSplitFailAggregation' | 'ApproachYellowRedActivationAggregation' | 'DetectorEventCountAggregation' | 'PhaseCycleAggregation' | 'PhaseLeftTurnGapAggregation' | 'PhasePedAggregation' | 'PhaseSplitMonitorAggregation' | 'PhaseTerminationAggregation' | 'PreemptionAggregation' | 'PriorityAggregation' | 'SignalEventCountAggregation' | 'SignalPlanAggregation',
    params?: GetAggregationDaysWithDataFromLocationIdentifierAndDataTypeParams,) => {
    return [`/api/v1/Aggregation/GetDaysWithData/${locationIdentifier}/${dataType}`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAggregationDaysWithDataFromLocationIdentifierAndDataTypeQueryOptions = <TData = Awaited<ReturnType<typeof getAggregationDaysWithDataFromLocationIdentifierAndDataType>>, TError = ProblemDetails>(locationIdentifier: string,
    dataType: 'AggregationApproachBase' | 'ApproachPcdAggregation' | 'ApproachSpeedAggregation' | 'ApproachSplitFailAggregation' | 'ApproachYellowRedActivationAggregation' | 'DetectorEventCountAggregation' | 'PhaseCycleAggregation' | 'PhaseLeftTurnGapAggregation' | 'PhasePedAggregation' | 'PhaseSplitMonitorAggregation' | 'PhaseTerminationAggregation' | 'PreemptionAggregation' | 'PriorityAggregation' | 'SignalEventCountAggregation' | 'SignalPlanAggregation',
    params?: GetAggregationDaysWithDataFromLocationIdentifierAndDataTypeParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAggregationDaysWithDataFromLocationIdentifierAndDataType>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAggregationDaysWithDataFromLocationIdentifierAndDataTypeQueryKey(locationIdentifier,dataType,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAggregationDaysWithDataFromLocationIdentifierAndDataType>>> = ({ signal }) => getAggregationDaysWithDataFromLocationIdentifierAndDataType(locationIdentifier,dataType,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(locationIdentifier && dataType), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAggregationDaysWithDataFromLocationIdentifierAndDataType>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAggregationDaysWithDataFromLocationIdentifierAndDataTypeQueryResult = NonNullable<Awaited<ReturnType<typeof getAggregationDaysWithDataFromLocationIdentifierAndDataType>>>
export type GetAggregationDaysWithDataFromLocationIdentifierAndDataTypeQueryError = ProblemDetails


/**
 * @summary Retrieves the distinct days that contain data for a specific location and data type
within the given date range.
 */

export function useGetAggregationDaysWithDataFromLocationIdentifierAndDataType<TData = Awaited<ReturnType<typeof getAggregationDaysWithDataFromLocationIdentifierAndDataType>>, TError = ProblemDetails>(
 locationIdentifier: string,
    dataType: 'AggregationApproachBase' | 'ApproachPcdAggregation' | 'ApproachSpeedAggregation' | 'ApproachSplitFailAggregation' | 'ApproachYellowRedActivationAggregation' | 'DetectorEventCountAggregation' | 'PhaseCycleAggregation' | 'PhaseLeftTurnGapAggregation' | 'PhasePedAggregation' | 'PhaseSplitMonitorAggregation' | 'PhaseTerminationAggregation' | 'PreemptionAggregation' | 'PriorityAggregation' | 'SignalEventCountAggregation' | 'SignalPlanAggregation',
    params?: GetAggregationDaysWithDataFromLocationIdentifierAndDataTypeParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAggregationDaysWithDataFromLocationIdentifierAndDataType>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAggregationDaysWithDataFromLocationIdentifierAndDataTypeQueryOptions(locationIdentifier,dataType,params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



